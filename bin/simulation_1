var Redis = require('ioredis');
var async = require('async');
var moment = require('moment');
var _ = require('underscore');
var config = require('../config');
var CronJob = require('cron').CronJob;

var redis = new Redis(config.redis.port);

// IMPORTANT: Make sure this is different for each simulation
var sim = 'simulation_1';
var sim_duration = 6;
var sim_max_allocation = 0.3;

// DEFAULT VALUES: Only used when the simulation is run for the first time
// subsequent runs will take these values from Redis (if updated via webserver)
var sim_portfolio = { 'coins': {'USDT': 1000}, 'base_coin': 'USDT'};
var sim_watch = ['ETH', 'BTC', 'LTC', 'XRP'];
var sim_buy_at = 1.03;
var sim_sell_at = 0.98;

// GLOBAL VARIABLES
var PORTFOLIO = {};

function buy ( coin, price ) {
	
	console.log('buy ' + coin + ' @ ' + price);
	
	var net_worth = PORTFOLIO['value_in_base_coin'];
	var base_coin = PORTFOLIO['base_coin'];
	var available_funds = PORTFOLIO['coins'][base_coin];
	
	var available_coins = 0;
	if ( PORTFOLIO['coins'][coin] ) { available_coins = PORTFOLIO['coins'][coin]; }
	
	if ( available_coins <= 0 &&  available_funds >= (sim_max_allocation * net_worth)) {
		
		var pay = sim_max_allocation * net_worth;
		var get = pay / price;
		var base_coin_after_trade = available_funds - pay;
		
		console.log('should get ' + get + ' ' + coin + ' coins @ ' + price);
		redis.multi([
		  ['set', sim + '-portfolio-' + coin, get],
		  ['set', sim + '-portfolio-' + base_coin, base_coin_after_trade]
		]).exec(function (err, results) {
			console.log('updated coin in redis: check...');
			console.log(results);
		});
	
	} else {
		console.log('already have ' + coin + ' or do not have funds to buy!');
		console.log('available ' + coin + ':' + available_coins);
		console.log('available funds: ' + available_funds);
	}
	
}


function sell ( coin, price ) {

	// console.log('sell ' + coin + ' @ ' + price);
	redis.hgetall('portfolio', function(err, portfolio) {
		
		var available_funds = portfolio['USDT'];
		
		var available_coins = 0;
		if ( portfolio[coin] ) { available_coins = portfolio[coin]; }
		
		if ( available_coins > 0 ) {
		
			var get = available_coins * price;
			console.log('should get ' + get + ' ' + USDT + ' coins @ ' + price);
			
			console.log('reset counter for ' + coin + ' @ SELL');
			redis.hset(sim + '-counter', coin, moment().format('x'));
		
		} else {
			console.log('do not have ' + coin + ', nothing to sell!');
		}
		
	}); 
}

function process ( ticker, callback ) {

	var coin = ticker.split('_')[1];
	
	var history = [];
	var buy_at = 0;
	var sell_at = 0;
	var last = 0;
	
	async.parallel([

		function (callback) {
			// get buy at price for coin
			redis.get(sim + '-buy-at-' + coin, function(err, result) {
				if ( ! result ) {
					buy_at = sim_buy_at;
					redis.set(sim + '-buy-at-' + coin, buy_at);
				}
				callback();
			}); 
		},
		
		function (callback) {
			// get sell at price for coin
			redis.get(sim + '-sell-at-' + coin, function(err, result) {
				if ( ! result ) {
					sell_at = sim_sell_at;
					redis.set(sim + '-sell-at-' + coin, sell_at);
				}
				callback();
			}); 
		},
		
		function (callback) {
		
			redis.hget(sim + '-counter', coin, function(err, results){
				
				var start_time = results;
				if ( ! results ) {
					start_time = moment().format('x');
					redis.hset(sim + '-counter', coin, start_time);
				}
				
				if ( start_time - moment().subtract(6, 'hour').format('x') <= 0 ) {
					console.log('reset counter for ' + coin + ' @ 6 HOURS');
					start_time = moment().format('x');
					redis.hset(sim + '-counter', coin, start_time);
				}
				
				redis.zrangebyscore('price-history-' + ticker, start_time, '+inf', function(err, result) {
					history = result;
					callback();
				}); 
			});
			
		},

		function (callback) {
			// get last price
			redis.get('price-last-' + ticker, function(err, result) {
				last = result;
				callback();
			}); 
		}
		
	], function(err){
		if (err) console.log('error processing ticker: ' + ticker);
		
		// need to implement a check on how many coins we are invested in...
		if ( last > (buy_at * _.min(history)) ) buy(coin, last);
		if ( last < (sell_at * _.max(history)) ) sell(coin, last);
	});
}

var job = new CronJob('* * * * * *', function() {
	// This function runs every second
	
	// Reset portfolio at each cycle
	PORTFOLIO = { 'coins': [], 'base_coin': '' };
	
	async.series([
	
		function(callback){
			// Get current portfolio
			redis.smembers(sim + '-portfolio-coins', function(err, results){
				
				if ( _.isEmpty(results) ) {
					
					console.log('portfolio has not been created in redis, let\'s do that...');
					async.each( _.keys(sim_portfolio['coins']), function(coin, callback){
						console.log('adding ' + sim_portfolio['coins'][coin] + ' ' + coin + ' to portfolio...');
						redis.sadd(sim + '-portfolio-coins', coin);
						redis.set(sim + '-portfolio-' + coin, sim_portfolio['coins'][coin]);
						callback();
						
					}, function(err){
						if (err) console.log('error creating portfolio in redis...');
						
						console.log('setting base coin to ' + sim_portfolio['base_coin'] + '...');
						redis.set(sim + '-portfolio-base_coin', sim_portfolio['base_coin']);
					});
					
				} else {
					
					async.each(results, function(coin, callback){
						redis.get(sim + '-portfolio-' + coin, function(err, results){
							PORTFOLIO['coins'].push({'coin' : coin, 'quantity' : results});
							callback();
						});
					}, function(err){
						if (err) console.log('error getting portfolio from redis...');
						
						redis.get(sim + '-portfolio-base_coin', function(err, results){
							PORTFOLIO['base_coin'] = results;
						});
					});

				}
				
				callback();
			});
		},
		
		function (callback) {
			// Get coins we are watching
			redis.smembers(sim + '-watching', function(err, results){
				
				if ( _.isEmpty(results) ) {
					
					console.log('watching set has not been created in redis, let\'s do that...');
					async.each( sim_watch, function(coin, callback){
						console.log('adding ' + coin + ' to watching set...');
						redis.sadd(sim + '-watching', coin);
						callback();
						
					}, function(err){
						if (err) console.log('error creating watching set in redis...');
					});
					
				} else {
					
					async.each(results, function(coin, callback){
						// console.log('processing ticker: ' + ticker);
						process( PORTFOLIO['base_coin'] + '_' + coin, function(err){
							if (err) console.log('error processing ticker: ' + ticker);
							callback();
						});
						
					}, function(err){
						if (err) console.log('error processing tickers!');
					});
					
				}
				
				callback();
				
			});
		}
	
	], function(err){
		if (err) console.log('error in simulation');
		
		console.log('terminating...');

	});

},  function() {
	console.log('terminating...');
}, true);
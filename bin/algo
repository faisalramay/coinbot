var Redis = require('ioredis');
var async = require('async');
var moment = require('moment');
var _ = require('underscore');
var config = require('../config');
var CronJob = require('cron').CronJob;

var redis = new Redis(config.redis.port);

// This should be a function
var counter = {};
var PORTFOLIO_VALUE = 1000;
var MAX_PER_COIN = 0.3;
var BUY_AT_X_MIN = 1.03;
var SELL_AT_X_MAX = 0.98;

function net () {
	// net worth, portfolio value...
	console.log('not implemented...');
}

function buy ( coin, price ) {
	
	console.log('buy ' + coin + ' @ ' + price);
	redis.hgetall('portfolio', function(err, portfolio) {
		
		var available_funds = portfolio['USDT'];
		
		var available_coins = 0;
		if ( portfolio[coin] ) { available_coins = portfolio[coin]; }
		
		if ( available_coins <= 0 &&  available_funds >= (MAX_PER_COIN * PORTFOLIO_VALUE)) {
		
			var pay = MAX_PER_COIN * PORTFOLIO_VALUE;
			var get = pay / price;
			
			console.log('should get ' + get + ' ' + coin + ' coins @ ' + price);
		
		} else {
			console.log('already have ' + coin + ' or do not have funds to buy!');
			console.log('available ' + coin + ':' + available_coins);
			console.log('available funds: ' + available_funds);
		}
		
	}); 
}

function sell ( coin, price ) {

	// console.log('sell ' + coin + ' @ ' + price);
	redis.hgetall('portfolio', function(err, portfolio) {
		
		var available_funds = portfolio['USDT'];
		
		var available_coins = 0;
		if ( portfolio[coin] ) { available_coins = portfolio[coin]; }
		
		if ( available_coins > 0 ) {
		
			var get = available_coins * price;
			console.log('should get ' + get + ' ' + USDT + ' coins @ ' + price);
			
			console.log('reset counter for ' + coin + ' @ SELL');
			counter[coin] = moment().format('x');
		
		} else {
			console.log('do not have ' + coin + ', nothing to sell!');
		}
		
	}); 
}

function process ( ticker, callback ) {

	var coin = ticker.split('_')[1];
	
	var portfolio = {};
	var history = [];
	var min = 0;
	var max = 0;
	var last = 0;
	
	async.parallel([

		function (callback) {
			// get portfolio
			redis.hgetall('portfolio', function(err, result) {
				portfolio = result;
				callback();
			}); 
		},
		
		function (callback) {
		
			// if counter has not be set, let's do that now ...
			if ( ! counter[coin] ) counter[coin] = moment().format('x');
			
			// if it has been more than 6 hours, reset ...
			if ( counter[coin] - moment().subtract(6, 'hour').format('x') <= 0 ) {
				console.log('reset counter for ' + coin + ' @ 6 HOURS');
				counter[coin] = moment().format('x');
			}
			
			redis.zrangebyscore('price-history-' + ticker, counter[coin], '+inf', function(err, result) {
				history = result;
				callback();
			}); 
		},

		function (callback) {
			// get last price
			redis.get('price-last-' + ticker, function(err, result) {
				last = result;
				callback();
			}); 
		}
		
	], function(err){
		if (err) console.log('error processing ticker: ' + ticker);
		
		// need to implement a check on how many coins we are invested in...
		if ( last > (BUY_AT_X_MIN * _.min(history)) ) buy(coin, last);
		if ( last < (SELL_AT_X_MAX * _.max(history)) ) sell(coin, last);
	});
}

var job = new CronJob('* * * * * *', function() {
	// This function runs every second
	
	// For each coin we are interested in
	redis.smembers('monitor', function(err, coins){
		async.each(coins, function(ticker, callback){
			
			// console.log('processing ticker: ' + ticker);
			process( ticker, function(err){
				if (err) console.log('error processing ticker: ' + ticker);
				callback();
			});
		}, function(err){
			if (err) {
				console.log('error processing tickers!');
			} else {
				console.log('iteration completed!');
			}
		});
	});
},  function() {
	console.log('terminating...');
}, true);